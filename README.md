
# NoiseBloc
## What is NoiseBloc
NoiseBloc product aims to revolutionize the way composers, producers, and all creators of audio content protect and manage their intellectual property rights. By integrating watermarking technology with the Polygon network, a part of the Ethereum blockchain, this software allows for the secure watermarking of audio files, enabling the tracking of ownership, transfers of ownership, and rights associated with each piece of audio content.
The vision behind this technology is to create a robust watermarking system capable of withstanding compression, decompression, and even AI-generated alterations, ensuring that the original source of the audio can always be traced back with just a second of the watermarked original clip.

In essence, this product aims to preserve the value of human-created audio content amidst the rise of AI-generated music, preventing a potential devaluation of human creativity. Much like how natural diamonds are distinguished from synthetic ones, this technology adds a layer of authenticity and value to audio content created by humans.

## Marking sound
The watermarking algorithm employs various techniques to embed a robust watermark into audio files. One approach involves distributing the watermark across multiple frequencies, making it resistant to EQ-based removal and robust against compression and decompression. Another method incorporates infrasound, ultrasound, and subtle audible frequencies, creating a dynamic signature that can be amplified for detection. By strategically selecting frequencies and utilizing advanced algorithms, the watermark remains intact even under manipulation.

## Blockchain integration - for transparency infinite tracing
Blockchain technology utilizes cryptographic hash functions to ensure the integrity and authenticity of data. When an NFT is created, a hash of the digital asset's metadata is stored on the blockchain, serving as a digital fingerprint. This ensures data security by making it practically impossible to recreate original data from a hash.

imagine a world where every audio file has a unique digital fingerprint that can be traced back to its original creator. This is the vision behind NoiseBlocs, a revolutionary technology that combines blockchain and audio watermarking to protect audio files from unauthorized use and manipulation. By embedding a watermark throughout the audio file and linking it to the blockchain, NoiseBlocs ensures that creators can easily assert their ownership rights and receive fair compensation for their work.



## Introduction 
In this prototype only a wav-file will work. To be able to execute the function an ethereum address is needed. For test purposes use one of the addresses generated by Ganashe or you can use this example code: 0xBa741A4C50D1ba416b123E25E811ADC433d00FB4

**---Ganashe is needed to be running to create a local Ethereum network which is used to deploy the smart contract---**
https://archive.trufflesuite.com/ganache/

## Order of preparation - command line
1. Run `npm install` to install dependencies.
2. Further dependencies  `npm install solc web3 pitchfinder node-wav`
3. `npm install solc@0.8.9`
4. `pip install scipy`
5. `pip install nump`
3. run `node server.js` to start back-end server
3. run `npm run dev` to launch web application 

### Server runs on localhost:3001
### Web-app runs on localhost:3000


## Manually compile and deploy the contract
### Only to test and try out different back-end functions
Run node compileContract.js to compile the contract and generate the ABI and bytecode.
Make sure Ganache is running.
Run node deploy.js to deploy the contract to your local Ethereum network.
Process the sound file:

Run node wavToJson.js to convert the sound file to JSON format.
Interact with the contract and modify the sound data:

Update the contract address in stringifySoundData.js.
Run node stringifySoundData.js to interact with the contract and generate hash.js.
Run node modifyPitchJson.js to modify the original JSON data.
Modify the original sound file:

Run python modifyOriginalWav.py to inject the new pitches into the original sound file.
This process can be run entirely from the command line, without needing to start a server or handle file uploads from a client. If you need to demonstrate this process in a more interactive way, you could create a simple command-line interface (CLI) for your scripts using a library like Inquirer.js.

-------------------------------------------------------------------------------------------------------


## Display added pitches function: 
User interacts with the UploadForm component:

User selects a .wav file and enters a valid Ethereum hash.
User clicks the 'Save' button to submit the form.
UploadForm component processes the form submission:

The onSubmit function is triggered.
The selected file and Ethereum hash are sent to the server via a POST request to 'http://localhost:3001/upload'.
The MarkSound process begins on the server.
MarkSound process completes on the server:

The server modifies the .wav file and generates the pitches.
The server saves the pitches to the added_pitches.json file.
UploadForm component fetches the new pitches:

After the MarkSound process is done, the onSubmit function fetches the new pitches from the server via a GET request to 'http://localhost:3001/pitches'.
The setPitches function is called with the new pitches, updating the pitches state.
PitchesDisplay component re-renders with the new pitches:

The change in the pitches state causes the PitchesDisplay component to re-render.
The PitchesDisplay component receives the new pitches prop and uses it to display the new pitches.
Here's a visual representation of the timeline:




                                                                                      
## Dokumentation samt Analys och Reflektion Ursprungliga projektet - uppdaterad

## Contract - Smarta kontrakt samt tillhörande kod
Mappen innehåller kod som är baserad och interagerar med det smarta kontraktet skrivet i Solidity -  ett programmeringsspråk som liknar JS men används för att skriva smarta kontrakt.
### HashMaker.sol
Kontraktet i koden tar emot en sträng och returnerar en keccak256 hash som sedan används av resterande kod. Eftersom koden inte går att använda när det ligger lokalt som en fil så måste det "deployas" till ett Ethereum nätverk. Ganache skapar ett lokalt testnätvek dit kontraktet kan "deployas" till det nätverket och interageras med.
### CompileContract.js
Gör om solidity-koden till ABI och Bytecode. Det är i princip två mkopior av samma kod i olika tappningar. ABI kan läsas och interagera med Javascript medans bytecode är det som laddas upp på ETH-nätverket. Koden sparar den omvandlade koden i data/MyContract.Json.
### Deploy.js
Koden laddar upp kontraktet till ETH-nätverket och skriver kontraktets adress i contractAddress.js

## Data
### hash.js
Hash som sparar transaktionshash när en transaktion görs (mintas) med andra ord den hashen somskapas  av HashMaker.sol och som kommer att användas till att märka ljudfilen.
## pitches.json 
Skapas av waveToJson.js och innehåller de 16 högsta frekvenserna i ljudfilen men avläsning var 5:e sekund.
## pitchesMod.json
Skapas av modifyPitchJson.js och är en uppdaterad version av pitches.json där decimaler har uppdaterats based på den transaktionshashen som skapats.
## MyCOntract.json 
Kontraktet som ligger upp på nätverket.

## APIn i node.js
### wavToJson.js
Skriver om 16 högsta frekvenserna från givna wav filen till en json fil med 5 sekunders intervall.
Koden börjar med att skapa en tonhöjdsdetektor med pitchfinder.YIN(). Definiera en funktion readWavFile för att läsa en WAV-fil och dekoda den till ett ljuddataobjekt.

"detectPitches" analyserar tonhöjder i ljuddatan. Funktionen går igenom ljuddata i bitar av en viss storlek, detekterar tonhöjden i varje bit, och lägger till den detekterade tonhöjden till en array.

getTopPitchesEvery5Seconds används för att få de topp 16 högsta frekvenserna var 5:e sekund. Funktionen går igenom tonhöjderna i bitar av en viss storlek, sorterar varje bit i fallande ordning, och lägger till de topp 16 tonhöjderna till en array.

writePitchesToFile för att skriva tonhöjderna till en JSON-fil.


### stringifySoundData.js

Koden börjar med att läsa in kontraktets ABI (Application Binary Interface) från MyContract.json och skapar en instans av Web3 som ansluter till en lokal Ethereum-nod på port 7545 på Mac (8545 på Linux). Sedan skapas även en instans av kontraktet med hjälp av ABI:n och kontraktsadressen.

Det hämtas en lista över konton från Ethereum-noden och skickar en transaktion från det första kontot till sig själv, med ett värde av 1 Ether och en gasgräns på 5000000. När transaktionen är klar, skriv transaktionshashet till hash.js.

Om det uppstår ett fel vid något av stegen, logga felet och några extra uppgifter för felsökning.

### modifyPitchJson.js
Den importerar ett transaktionshash från hash.js som är en hexadecimal (0-9 och A-F), tar bort prefixet '0x' från hashet och delar de återstående tecknen i par.

Varje par tecken omvandlas till en decimaltal mellan 1 och 16. Detta görs genom att tolka paret som ett hexadecimalt tal , ta resten när det delas med 16 (med modulusoperatören %), och sedan lägga till 1 för att alltid ha ett nummer mellan 1 och 16.
Sedan läser koden in en JSON-fil som heter pitches.json som innehåller en array av objekt. Varje objekt har en egenskap pitches som är en array av tal.

Den modifierar tonhöjderna (siffrorna) i varje objekt med hjälp av hashnumren. Den tar varje par av tecken från hashsträngen, omvandlar det till ett decimaltal mellan 1 och 16, och lägger sedan till det talet till motsvarande tonhöjd i pitches arrayen. Om det finns fler tonhöjder än par av tecken i hashsträngen, börjar den om från början av hashnumren. Detta kallas att använda numren på ett cykliskt sätt.

Den skriver tillbaka de modifierade datan till en ny JSON-fil som heter pitchesMod.json.


## Server.js
Node.js server som använder ett Express.js ramverk för att skapa endpoints som ladda upp filer, kompilera och distribuera kontrakt, bearbeta ljud, modifiera ljud, hämta tonhöjder, markera och rensa tonhöjder. Servern använder även Multer som "middleware" för att hantera filuppladdning i Express. Lagrar filer som arbetas med och som laddats upp på webbapplikationen i uploads mappen.
Gör det lättare att specificera ver och hr filerna ska lagras på servern (eller min lokala dator vid detta tillfället). Axios används för att göra HTTP förfrågningar från webbläsare och node.js.
Eftersom servern är aktiv på 3001 och sidan på 3000 använder jag också CORS för att tillåta förfrågningar.

Servern skapar en Express-app, aktiverar Cors och definerear funktionen execCommand för att kunna aktivera terminalkommandeon från react-frontend.

### POST Endpoints
POST - vägen: /upload för att ladda upp en fil. Den använder multer för att hantera filuppladdningen. Efter att filen är laddas upp, kompileras och distribueras ett kontrakt, ljudet bearbetas, ljudet modifieras och den modifierade ljudfilen skickas som en nedladdning.
 
POST - endponts /compileAndDeploy, /processSound och /modifySound för att kompilera och distribuera ett kontrakt, bearbeta ljud och modifiera ljud, respektive. Varje slutpunkt kör ett terminalkommando.

### GET Endpoints
GET /pitches för att hämta tonhöjder. Den läser tonhöjderna från en JSON-fil och skickar dem som ett JSON-svar.

GET /mark och /clear_pitches för att markera och rensa tonhöjder. /mark gör en GET-förfrågan till http://localhost:3001/clear_pitches och skickar ett svar baserat på statusen för förfrågan. Den aktiverar / clear_pitches när sidan laddas och tömmer added_pitches.json - kan sedan köras på local storage eller IndexDB om det används istället.


## modifyOriginalWav.py - Addera toner till original-ljudet
Eftersom jag inte hittade ett bra nog och passande bibliotek i JS för att arbeta med ljud och ljudsynteses så var jag tvungen att använda mig utav Python som rä känt för att ha bra och väldokumentarade ramverk för att arbeta med ljud.
Python-koden modifierar original-ljudfil genom att lägga till tonhöjder vid regelbundna intervaller. Sökvägen till ljudfilen hämtas från kommandoradsargumenten och ljudfilen läses in, vilket ger samplingshastigheten och ljuddata. Ljuddata konverteras till en float-array (varje tal har en decimaler) och de modifierade tonhöjderna laddas från pitchesMod.json.

Ljudfilen delas in i tidsfönser var tredje sekund där toner på 25 milisekunder senare läggs in. För varje fönster i de modifierade tonhöjderna väljs en slumpmässig tonhöjd, skrivs ut, läggs till i en svag nyans till det ursprungliga ljudet var 3:e sekund. De tillagda tonhöjderna sparas till added_pithces.json.

Det ursprungliga ljudet blandas med de tillagda tonhöjderna. Om ljudet är mono, läggs tonhöjderna direkt till. Om ljudet är stereo, läggs tonhöjderna till varje kanal. De blandade datan säkerställs att inte överstiga int16-området och konverteras till en 16-bitars heltalsarray. Slutligen skrivs de blandade datan till en ny WAV-fil i en specifik katalog.
När man blandar det ursprungliga ljudet med de tillagda tonhöjderna, kan resultatet bli ett tal som ligger utanför int16-intervallet. Om du försöker att skriva detta tal till en WAV-fil som ett 16-bitars heltal, kommer det att klippas till -32768 eller 32767, vilket kan orsaka att ljudet "distar".

## Komponenter

### Header 
Renderar en navigeringsheader för webbapplikationen. Innehåller en rubrik som också är länk till startsidan opch länkarna till: Bloc, Noise, About och Contact.

### Footer 
Innehåller i nuläget endast information om Copyright men kan senare innehålla andra länkar.

### ContactFrom
Innehåller ett färdigt kontaktformulär som behöver kopplas upp.

### Container
Renderar {children} istället för att uppdatera hela sidan, håller reda på innehållet i "containern".

### MarkSound
Komponent som tar emot filer och pratar med backend server och tar emot hash från användaren som sedan används vid bearbetningen av ljudet sam kontrollerar att hashen är i korrekt format.

### ShowModifiedPitches
Visar adderade frekvenser och tidskod på sidan efter att ljudfil märkts. Suddas ut vid omrendering av sidan /mark.


## Sidor

### Noise/page 
Renderar innehållet för sidan "Noise". Innehåller information om själva vattenmärkningsteknologin.

### Blox/page 
Innehållet information om integrationen med blockchain. 

### About/page
Innehåller information om teamet bakom vilket i nuläget endast är jag själv.

### Contact/page
Innehåller kontaktformulär från ContactForm som kommer att göra det möjligt för användare att direkt på sidan kontakta teamet bakom.

### Mark/page
Innehåller komponenterna för att märka ljud samt visa vilka frekvenser som lagts till.

## Översikt
        Ge en kort sammanfattning av koden och dess syfte.
I koden så har jag skapat en SPA baserat på min produkt eller teknologi jag tagit fram i tidigare kursen Affärsmannaskap. Sidan presenterar min produkt NoiseBloc som är en teknologi för att vattenmärka och integrera ljud i blockchain-nätverket för att spåra ägande och rättigheter lättare. Sidan ahr idag inga av de teknologiska funktioner den kommer att ha senare utan är bara ett skal för det som kommer att bli en fullskalig webbapplikation.

## Funktioner:

Sidan består av en huvudsida som kort beskriver vad teknologin gör och vad applikationen är tänkte att kunna hjälpa med samt vilka som är målgruppen. Till denna har jag tre undersidor som heter: About, Bloc, Noise och Contact. About och Contact följer standard för vad hemsidor brukar innehåll. Med about om skaparen av teknologin och senare kommer även teamet bakom att stå med. I contact så finns ett formulär som sedan kommer att "routas" upp mot ett API där användare direkt ska kunna kontakta teamet. Eftersom uppgiften endast krävde ett skal så är detta något jag kommer att göra senare. 
Koden och sidan i sig ska förmedla en känsla av hur applikationen är tänkt att bli. Med sin design så riktar den också in sig på den specifika målgruppen men gör det inte heller för invecklat att navigera eller ställer för höga krav på att användaren ska vara tekniskt kunnig.
I Bloc sidan beskriver jag hur teknologin är integrerad med polygon nätverket och hur det bidrar till att underlätta spårning, skydda upphovsrätt och registrera en permanent upphovsperson till ett verk.
I Noise Beskriver jag hur vattenmärkningstknologin hänger ihop med blockchain och hur den vattenmärker ljudfilerna för att sedan kunna spåra dem. 
Dessa två kommer när sida skalas upp och byggs på med den faktiska teknologin kunna gå under en dropdown meny, under rubriken "about".

## Komponenter, ingågnar/utgångar

De komponenterna jag hittills använt mig av är ett "ContactForm", "Header", "Footer" och "Container". I kontaktformuläret finns ett färdigt kontaktformulär redo att kopplas upp. I Header så har jag länkar till alla sidor jag har på hemsidan så de finns tillgängliga och lätta att navigera. Footer innehåller endast copyright info + man skulle senare kunna flytta kontakt länken ner dit men det är inget som behövs nu.
Till sist har jag en container som förenklar att sidan kan uppdatera {children} utan att behöva uppdatera hela sidan. 
Alla dessa routas till Layout där allt sätts ihop till det som syns på mitt SPA.


## Analys och Reflektion - Uppdaterad

Själva poängen och användandet av React komponenter är att kunna återavnända dessa komponenter, lagra så mycket som möjligt i cashen och därigenom få den ultimata prestandan. Även Virtual DOM tillåter en smidig generering av sidan. Jag började först med att plugga på och prova göra sidor med Vite vilket jag tyckte om och på många sätt var smidigare att komma in i än Next JS eftersom man fortfarande behöll index.html filen och all kod genererades genom den. 
Dock så förstår jag nu efter att ha använt Next JS att det finns många fördelar med detta, inte minst när det kommer till routing som blir väldigt tydligt och enkelt. Vad gäller komponenter så fungerar det ju på liknande sätt och det är ett arbetssätt som jag uppskattar tydligheten i. 

Det är just detta modulära sätt att strukturera koden på som senare gör det så lätt att underhålla och uppdatera koden. Jag förstår direkt intuitivt koden och vad de olika delarna göra genom att bara titta på filsystemet och hur det är uppbyggt vilken ger en som en slags karta över hela koden där man lätt kan välja och hitta det man vill uppdatera eller manipulera.Här blir också en tydlig dokumentation samt tydliga namn på komponenter viktigt för att utvecklaren själv och andra ska kunna koppla sidor och komponenter tills jävla hemsidan och vad de gör lätt.

I takt med att det kommer att läggas till fler bilder och även videor och ljud så är det viktigt att dessa är optimerade för sidan för att höja prestandan. En annan tanke jag haft under arbetets gång är att jag förstår varför många större företag eller etablerade organisationer använder sig utav Typescript när man arbetar med React och front-end eftersom det blir så mycket mer konkret och lättare att underhålla och skala över en längre tid.
Mitt nästa mål och kanske redan med detta projektet är att göra om det men med typescript istället för att just få de begränsningarna typescript erbjuder. Sedan liknar det ju C# lite mer i tänket vilket jag uppskattar. 

Smarta kontrakt och vattenmärkning

Projektet blev mycket större än vad jag hade tänkt och vissa oförutsedda händelser måste kom upp som gjorde att det blev mer "skräddarsytt" än vad jag tänkt till en början. Eftersom jag ville ha tillgång till hashen som skapas när man mintar något till ett etheretum nätverk så kunde jag inte använda "Truffle" som annars är ett bra sätt att kompilera om kod från solidity och "deploy:a" till ett testnätverk eller till ett riktigt ethereum nätverk.
Jag blev därför att skriva en egen "compiler" och "deployer" vilket inte visade vara sås vårt som jag trott. Det som varit det absolut svåraste är att både Solidity som språk men också hela Web3 som används för att skapa en instans av det uppladdade kontraktet för att kunna interagera med det lokalt och på så sätt tillhandahålla en hash utan att ladda upp någon till nätverket. Ljudet kan då vattenmärkas innan hashen laddas upp på nätverket och kan då förknippas med ljudfilen. 
Det jag fick mest problem med är att eftersom teknologin och språket är så nytt och det väldigt snabbt kommer uppdateringar och olika versioner så är det svårt att hitta dokumentation som är uppdaterad. Köpte en Udemykurs men tyvärr var det mest utdaterat och det är ibland så stora skillnader i syntax och hur man gör något att ett äldre sätt inte alls fungerar.

Vattenmärkningsprocessen kan göras på många olika sätt och jag fokuserade vid detta tillfället påa tt skapa en bra prototyp som kan märka ljud utan att det påverkar ljudets kvalite och göra all data som går in in ljudet så tydligt som möjligt för användaren. Därför valde jag att skriva ut alla adderade toner direkt på hemsidan för att göra det tydligare. Detta kan vara kvar i den framtida appen också men måste tas bort vid nedstängning av sidan. Det är inte heller något som bör ligga uppe på en server någonstans då man med den informationen skulle kunna mixtra med ljudet för att ogiltigöga vattenmärkninen. Det som kommer finnas och som kan identifiera ljuden är hashen som kommer att ligga på blockchainen och vara tillgänglig för alla - den identifierar ägaren och används för att vattenmärka ljudet.

Det som bör göras i framtiden är att påbörja skapandet av programvara som kan identifiera ljuden genom att avläsa med hjälp av hashen göra en liknande behandling av ljudet som kontrolleras och sedan jämföra ljuden. JAg tänker mig att det ska fungera på samma sätt som lösenord sparas och avkodas vid inloggning. Det kan betyda att jag också får modifiera denna koden och anpassa den efter avkodningen också. Säkerheten kring systemet och lagring av kod kommer också bli viktigare vid framtida projekt.
En anna tank är också att använda mig av Polygon som ligger på Ethernätverket eftersom det har mindre avgifter eller "gas fees". 
När man arbetar med blockchain är det viktigt att veta att till skillnad mot vanlig programmering så handlar det om transaktioner och många anrop hanteras som transaktioner. Att skicka ett GET anrop är gratis men att skicka ett POST kostar beroende på hur mycket och vad det är som ska bearbetas.

//Alfred Jimenez




**-------------------------------------------------------------------------**

##React and Next Js Documentation

This is a [Next.js](https://nextjs.org/) project bootstrapped with [`create-next-app`](https://github.com/vercel/next.js/tree/canary/packages/create-next-app).


## Getting Started
This is a [Next.js](https://nextjs.org/) project bootstrapped with [`create-next-app`](https://github.com/vercel/next.js/tree/canary/packages/create-next-app).

## Getting Started

First, run the development server:

```bash
npm run dev
# or
yarn dev
# or
pnpm dev
# or
bun dev
```

Open [http://localhost:3000](http://localhost:3000) with your browser to see the result.

You can start editing the page by modifying `app/page.tsx`. The page auto-updates as you edit the file.

This project uses [`next/font`](https://nextjs.org/docs/basic-features/font-optimization) to automatically optimize and load Inter, a custom Google Font.

## Learn More

To learn more about Next.js, take a look at the following resources:

- [Next.js Documentation](https://nextjs.org/docs) - learn about Next.js features and API.
- [Learn Next.js](https://nextjs.org/learn) - an interactive Next.js tutorial.

You can check out [the Next.js GitHub repository](https://github.com/vercel/next.js/) - your feedback and contributions are welcome!

## Deploy on Vercel

The easiest way to deploy your Next.js app is to use the [Vercel Platform](https://vercel.com/new?utm_medium=default-template&filter=next.js&utm_source=create-next-app&utm_campaign=create-next-app-readme) from the creators of Next.js.

Check out our [Next.js deployment documentation](https://nextjs.org/docs/deployment) for more details.

