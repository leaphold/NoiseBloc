
# NoiseBloc

The watermarking algorithm employs various techniques to embed a robust watermark into audio files. One approach involves distributing the watermark across multiple frequencies, making it resistant to EQ-based removal and robust against compression and decompression. Another method incorporates infrasound, ultrasound, and subtle audible frequencies, creating a dynamic signature that can be amplified for detection. By strategically selecting frequencies and utilizing advanced algorithms, the watermark remains intact even under manipulation.

Blockchain technology utilizes cryptographic hash functions to ensure the integrity and authenticity of data. When an NFT is created, a hash of the digital asset's metadata is stored on the blockchain, serving as a digital fingerprint. This ensures data security by making it practically impossible to recreate original data from a hash.

imagine a world where every audio file has a unique digital fingerprint that can be traced back to its original creator. This is the vision behind NoiseBlocs, a revolutionary technology that combines blockchain and audio watermarking to protect audio files from unauthorized use and manipulation. By embedding a watermark throughout the audio file and linking it to the blockchain, NoiseBlocs ensures that creators can easily assert their ownership rights and receive fair compensation for their work.



## Introduction 
In this prototype only a wav-file will work. To be able to execute the function an ethereum adress is needed. For test purposes use one of the addresses generated by ganashe or you can use this one: 0xBa741A4C50D1ba416b123E25E811ADC433d00FB4

## Order of preparation - command line
1. run `npm install` to install dependencies.
2. run `node server.js` to start back-end server
3. run `npm run dev` to launch web application 

### Server runs on localhost:3001
### Web-app runs on localhost:3000


## Compile and deploy the contract - Manually:
### Only to test and try out different back-end functions
Run node compileContract.js to compile the contract and generate the ABI and bytecode.
Make sure Ganache is running.
Run node deploy.js to deploy the contract to your local Ethereum network.
Process the sound file:

Run node wavToJson.js to convert the sound file to JSON format.
Interact with the contract and modify the sound data:

Update the contract address in stringifySoundData.js.
Run node stringifySoundData.js to interact with the contract and generate hash.js.
Run node modifyPitchJson.js to modify the original JSON data.
Modify the original sound file:

Run python modifyOriginalWav.py to inject the new pitches into the original sound file.
This process can be run entirely from the command line, without needing to start a server or handle file uploads from a client. If you need to demonstrate this process in a more interactive way, you could create a simple command-line interface (CLI) for your scripts using a library like Inquirer.js.

-------------------------------------------------------------------------------------------------------


## Display added pitches function: 

User interacts with the UploadForm component:

User selects a .wav file and enters a valid Ethereum hash.
User clicks the 'Save' button to submit the form.
UploadForm component processes the form submission:

The onSubmit function is triggered.
The selected file and Ethereum hash are sent to the server via a POST request to 'http://localhost:3001/upload'.
The MarkSound process begins on the server.
MarkSound process completes on the server:

The server modifies the .wav file and generates the pitches.
The server saves the pitches to the added_pitches.json file.
UploadForm component fetches the new pitches:

After the MarkSound process is done, the onSubmit function fetches the new pitches from the server via a GET request to 'http://localhost:3001/pitches'.
The setPitches function is called with the new pitches, updating the pitches state.
PitchesDisplay component re-renders with the new pitches:

The change in the pitches state causes the PitchesDisplay component to re-render.
The PitchesDisplay component receives the new pitches prop and uses it to display the new pitches.
Here's a visual representation of the timeline:










## Reflektion - API






















##React and Next Js Documentation

This is a [Next.js](https://nextjs.org/) project bootstrapped with [`create-next-app`](https://github.com/vercel/next.js/tree/canary/packages/create-next-app).


## Getting Started
=======
This is a [Next.js](https://nextjs.org/) project bootstrapped with [`create-next-app`](https://github.com/vercel/next.js/tree/canary/packages/create-next-app).

## Getting Started

>>>>>>> master
First, run the development server:

```bash
npm run dev
# or
yarn dev
# or
pnpm dev
<<<<<<< HEAD
=======
# or
bun dev
>>>>>>> master
```

Open [http://localhost:3000](http://localhost:3000) with your browser to see the result.

<<<<<<< HEAD
You can start editing the page by modifying `app/page.js`. The page auto-updates as you edit the file.
=======
You can start editing the page by modifying `app/page.tsx`. The page auto-updates as you edit the file.
>>>>>>> master

This project uses [`next/font`](https://nextjs.org/docs/basic-features/font-optimization) to automatically optimize and load Inter, a custom Google Font.

## Learn More

To learn more about Next.js, take a look at the following resources:

- [Next.js Documentation](https://nextjs.org/docs) - learn about Next.js features and API.
- [Learn Next.js](https://nextjs.org/learn) - an interactive Next.js tutorial.

You can check out [the Next.js GitHub repository](https://github.com/vercel/next.js/) - your feedback and contributions are welcome!

## Deploy on Vercel

The easiest way to deploy your Next.js app is to use the [Vercel Platform](https://vercel.com/new?utm_medium=default-template&filter=next.js&utm_source=create-next-app&utm_campaign=create-next-app-readme) from the creators of Next.js.

Check out our [Next.js deployment documentation](https://nextjs.org/docs/deployment) for more details.





                                                                                      
# Dokumentation samt Analys och Reflektion Ursprunglig

## Komponenter

### Header 
Renderar en navigeringsheader för webbapplikationen. Innehåller en rubrik som också är länk till startsidan opch länkarna till: Bloc, Noise, About och Contact.

### Footer 
Innehåller i nuläget endast information om Copyright men kan senare innehålla andra länkar.

### ContactFrom
Innehåller ett färdigt kontaktformulär som behöver kopplas upp.

### Container
Renderar {children} istället för att uppdatera hela sidan, håller reda på innehållet i "containern".


## Sidor

### Noise/page 
Renderar innehållet för sidan "Noise". Innehåller information om själva vattenmärkningsteknologin.

### Blox/page 
Innehållet information om integrationen med blockchain. 

### About/page
Innehåller information om teamet bakom vilket i nuläget endast är jag själv.

### Contact/page
Innehåller kontaktformulär från ContactForm som kommer att göra det möjligt för användare att direkt på sidan kontakta teamet bakom.



## Översikt
        Ge en kort sammanfattning av koden och dess syfte.
I koden så har jag skapat en SPA baserat på min produkt eller teknologi jag tagit fram i tidigare kursen Affärsmannaskap. Sidan presenterar min produkt NoiseBloc som är en teknologi för att vattenmärka och integrera ljud i blockchain-nätverket för att spåra ägande och rättigheter lättare. Sidan ahr idag inga av de teknologiska funktioner den kommer att ha senare utan är bara ett skal för det som kommer att bli en fullskalig webbapplikation.

## Funktioner:

Sidan består av en huvudsida som kort beskriver vad teknologin gör och vad applikationen är tänkte att kunna hjälpa med samt vilka som är målgruppen. Till denna har jag tre undersidor som heter: About, Bloc, Noise och Contact. About och Contact följer standard för vad hemsidor brukar innehåll. Med about om skaparen av teknologin och senare kommer även teamet bakom att stå med. I contact så finns ett formulär som sedan kommer att "routas" upp mot ett API där användare direkt ska kunna kontakta teamet. Eftersom uppgiften endast krävde ett skal så är detta något jag kommer att göra senare. 
Koden och sidan i sig ska förmedla en känsla av hur applikationen är tänkt att bli. Med sin design så riktar den också in sig på den specifika målgruppen men gör det inte heller för invecklat att navigera eller ställer för höga krav på att användaren ska vara tekniskt kunnig.
I Bloc sidan beskriver jag hur teknologin är integrerad med polygon nätverket och hur det bidrar till att underlätta spårning, skydda upphovsrätt och registrera en permanent upphovsperson till ett verk.
I Noise Beskriver jag hur vattenmärkningstknologin hänger ihop med blockchain och hur den vattenmärker ljudfilerna för att sedan kunna spåra dem. 
Dessa två kommer när sida skalas upp och byggs på med den faktiska teknologin kunna gå under en dropdown meny, under rubriken "about".

## Komponenter, ingågnar/utgångar

De komponenterna jag hittills använt mig av är ett "ContactForm", "Header", "Footer" och "Container". I kontaktformuläret finns ett färdigt kontaktformulär redo att kopplas upp. I Header så har jag länkar till alla sidor jag har på hemsidan så de finns tillgängliga och lätta att navigera. Footer innehåller endast copyright info + man skulle senare kunna flytta kontakt länken ner dit men det är inget som behövs nu.
Till sist har jag en container som förenklar att sidan kan uppdatera {children} utan att behöva uppdatera hela sidan. 
Alla dessa routas till Layout där allt sätts ihop till det som syns på mitt SPA.


## Analys och Reflektion

Själva poängen och användandet av React komponenter är att kunna återavnända dessa komponenter, lagra så mycket som möjligt i cashen och därigenom få den ultimata prestandan. Även Virtual DOM tillåter en smidig generering av sidan. Jag började först med att plugga på och prova göra sidor med Vite vilket jag tyckte om och på många sätt var smidigare att komma in i än Next JS eftersom man fortfarande behöll index.html filen och all kod genererades genom den. 
Dock så förstår jag nu efter att ha använt Next JS att det finns många fördelar med detta, inte minst när det kommer till routing som blir väldigt tydligt och enkelt. Vad gäller komponenter så fungerar det ju på liknande sätt och det är ett arbetssätt som jag uppskattar tydligheten i. 

Det är just detta modulära sätt att strukturera koden på som senare gör det så lätt att underhålla och uppdatera koden. Jag förstår direkt intuitivt koden och vad de olika delarna göra genom att bara titta på filsystemet och hur det är uppbyggt vilken ger en som en slags karta över hela koden där man lätt kan välja och hitta det man vill uppdatera eller manipulera.Här blir också en tydlig dokumentation samt tydliga namn på komponenter viktigt för att utvecklaren själv och andra ska kunna koppla sidor och komponenter tills jävla hemsidan och vad de gör lätt.

I takt med att det kommer att läggas till fler bilder och även videor och ljud så är det viktigt att dessa är optimerade för sidan för att höja prestandan. En annan tanke jag haft under arbetets gång är att jag förstår varför många större företag eller etablerade organisationer använder sig utav Typescript när man arbetar med React och front-end eftersom det blir så mycket mer konkret och lättare att underhålla och skala över en längre tid.
Mitt nästa mål och kanske redan med detta projektet är att göra om det men med typescript istället för att just få de begränsningarna typescript erbjuder. Sedan liknar det ju C# lite mer i tänket vilket jag uppskattar. 





//Alfred Jimenez
